/* automatically generated by rust-bindgen */

pub const FFT_FORWARD: u32 = 1;
pub const FFT_BACKWARD: u32 = 2;
pub const FFT_ESTIMATE: u32 = 3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CheapTrickOption {
    pub q1: f64,
    pub f0_floor: f64,
    pub fft_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CheapTrickOption() {
    assert_eq!(
        ::std::mem::size_of::<CheapTrickOption>(),
        24usize,
        concat!("Size of: ", stringify!(CheapTrickOption))
    );
    assert_eq!(
        ::std::mem::align_of::<CheapTrickOption>(),
        8usize,
        concat!("Alignment of ", stringify!(CheapTrickOption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CheapTrickOption>())).q1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CheapTrickOption),
            "::",
            stringify!(q1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CheapTrickOption>())).f0_floor as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CheapTrickOption),
            "::",
            stringify!(f0_floor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CheapTrickOption>())).fft_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CheapTrickOption),
            "::",
            stringify!(fft_size)
        )
    );
}
extern "C" {
    pub fn CheapTrick(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        temporal_positions: *const f64,
        f0: *const f64,
        f0_length: ::std::os::raw::c_int,
        option: *const CheapTrickOption,
        spectrogram: *mut *mut f64,
    );
}
extern "C" {
    pub fn InitializeCheapTrickOption(fs: ::std::os::raw::c_int, option: *mut CheapTrickOption);
}
extern "C" {
    pub fn GetFFTSizeForCheapTrick(
        fs: ::std::os::raw::c_int,
        option: *const CheapTrickOption,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn GetF0FloorForCheapTrick(
        fs: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    pub fn GetNumberOfAperiodicities(fs: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn CodeAperiodicity(
        aperiodicity: *const *const f64,
        f0_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        coded_aperiodicity: *mut *mut f64,
    );
}
extern "C" {
    pub fn DecodeAperiodicity(
        coded_aperiodicity: *const *const f64,
        f0_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        aperiodicity: *mut *mut f64,
    );
}
extern "C" {
    pub fn CodeSpectralEnvelope(
        spectrogram: *const *const f64,
        f0_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        number_of_dimensions: ::std::os::raw::c_int,
        coded_spectral_envelope: *mut *mut f64,
    );
}
extern "C" {
    pub fn DecodeSpectralEnvelope(
        coded_spectral_envelope: *const *const f64,
        f0_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        number_of_dimensions: ::std::os::raw::c_int,
        spectrogram: *mut *mut f64,
    );
}
pub type fft_complex = [f64; 2usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fft_plan {
    pub n: ::std::os::raw::c_int,
    pub sign: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_uint,
    pub c_in: *mut fft_complex,
    pub in_: *mut f64,
    pub c_out: *mut fft_complex,
    pub out: *mut f64,
    pub input: *mut f64,
    pub ip: *mut ::std::os::raw::c_int,
    pub w: *mut f64,
}
#[test]
fn bindgen_test_layout_fft_plan() {
    assert_eq!(
        ::std::mem::size_of::<fft_plan>(),
        72usize,
        concat!("Size of: ", stringify!(fft_plan))
    );
    assert_eq!(
        ::std::mem::align_of::<fft_plan>(),
        8usize,
        concat!("Alignment of ", stringify!(fft_plan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).sign as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(sign)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).c_in as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(c_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).in_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(in_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).c_out as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(c_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).out as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).input as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).ip as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fft_plan>())).w as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(fft_plan),
            "::",
            stringify!(w)
        )
    );
}
extern "C" {
    pub fn fft_plan_dft_1d(
        n: ::std::os::raw::c_int,
        in_: *mut fft_complex,
        out: *mut fft_complex,
        sign: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_uint,
    ) -> fft_plan;
}
extern "C" {
    pub fn fft_plan_dft_c2r_1d(
        n: ::std::os::raw::c_int,
        in_: *mut fft_complex,
        out: *mut f64,
        flags: ::std::os::raw::c_uint,
    ) -> fft_plan;
}
extern "C" {
    pub fn fft_plan_dft_r2c_1d(
        n: ::std::os::raw::c_int,
        in_: *mut f64,
        out: *mut fft_complex,
        flags: ::std::os::raw::c_uint,
    ) -> fft_plan;
}
extern "C" {
    pub fn fft_execute(p: fft_plan);
}
extern "C" {
    pub fn fft_destroy_plan(p: fft_plan);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ForwardRealFFT {
    pub fft_size: ::std::os::raw::c_int,
    pub waveform: *mut f64,
    pub spectrum: *mut fft_complex,
    pub forward_fft: fft_plan,
}
#[test]
fn bindgen_test_layout_ForwardRealFFT() {
    assert_eq!(
        ::std::mem::size_of::<ForwardRealFFT>(),
        96usize,
        concat!("Size of: ", stringify!(ForwardRealFFT))
    );
    assert_eq!(
        ::std::mem::align_of::<ForwardRealFFT>(),
        8usize,
        concat!("Alignment of ", stringify!(ForwardRealFFT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForwardRealFFT>())).fft_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ForwardRealFFT),
            "::",
            stringify!(fft_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForwardRealFFT>())).waveform as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ForwardRealFFT),
            "::",
            stringify!(waveform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForwardRealFFT>())).spectrum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ForwardRealFFT),
            "::",
            stringify!(spectrum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ForwardRealFFT>())).forward_fft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ForwardRealFFT),
            "::",
            stringify!(forward_fft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InverseRealFFT {
    pub fft_size: ::std::os::raw::c_int,
    pub waveform: *mut f64,
    pub spectrum: *mut fft_complex,
    pub inverse_fft: fft_plan,
}
#[test]
fn bindgen_test_layout_InverseRealFFT() {
    assert_eq!(
        ::std::mem::size_of::<InverseRealFFT>(),
        96usize,
        concat!("Size of: ", stringify!(InverseRealFFT))
    );
    assert_eq!(
        ::std::mem::align_of::<InverseRealFFT>(),
        8usize,
        concat!("Alignment of ", stringify!(InverseRealFFT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseRealFFT>())).fft_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseRealFFT),
            "::",
            stringify!(fft_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseRealFFT>())).waveform as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseRealFFT),
            "::",
            stringify!(waveform)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseRealFFT>())).spectrum as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseRealFFT),
            "::",
            stringify!(spectrum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseRealFFT>())).inverse_fft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseRealFFT),
            "::",
            stringify!(inverse_fft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InverseComplexFFT {
    pub fft_size: ::std::os::raw::c_int,
    pub input: *mut fft_complex,
    pub output: *mut fft_complex,
    pub inverse_fft: fft_plan,
}
#[test]
fn bindgen_test_layout_InverseComplexFFT() {
    assert_eq!(
        ::std::mem::size_of::<InverseComplexFFT>(),
        96usize,
        concat!("Size of: ", stringify!(InverseComplexFFT))
    );
    assert_eq!(
        ::std::mem::align_of::<InverseComplexFFT>(),
        8usize,
        concat!("Alignment of ", stringify!(InverseComplexFFT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseComplexFFT>())).fft_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseComplexFFT),
            "::",
            stringify!(fft_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseComplexFFT>())).input as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseComplexFFT),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseComplexFFT>())).output as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseComplexFFT),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<InverseComplexFFT>())).inverse_fft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(InverseComplexFFT),
            "::",
            stringify!(inverse_fft)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MinimumPhaseAnalysis {
    pub fft_size: ::std::os::raw::c_int,
    pub log_spectrum: *mut f64,
    pub minimum_phase_spectrum: *mut fft_complex,
    pub cepstrum: *mut fft_complex,
    pub inverse_fft: fft_plan,
    pub forward_fft: fft_plan,
}
#[test]
fn bindgen_test_layout_MinimumPhaseAnalysis() {
    assert_eq!(
        ::std::mem::size_of::<MinimumPhaseAnalysis>(),
        176usize,
        concat!("Size of: ", stringify!(MinimumPhaseAnalysis))
    );
    assert_eq!(
        ::std::mem::align_of::<MinimumPhaseAnalysis>(),
        8usize,
        concat!("Alignment of ", stringify!(MinimumPhaseAnalysis))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinimumPhaseAnalysis>())).fft_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MinimumPhaseAnalysis),
            "::",
            stringify!(fft_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MinimumPhaseAnalysis>())).log_spectrum as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MinimumPhaseAnalysis),
            "::",
            stringify!(log_spectrum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MinimumPhaseAnalysis>())).minimum_phase_spectrum as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MinimumPhaseAnalysis),
            "::",
            stringify!(minimum_phase_spectrum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MinimumPhaseAnalysis>())).cepstrum as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MinimumPhaseAnalysis),
            "::",
            stringify!(cepstrum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MinimumPhaseAnalysis>())).inverse_fft as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MinimumPhaseAnalysis),
            "::",
            stringify!(inverse_fft)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MinimumPhaseAnalysis>())).forward_fft as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MinimumPhaseAnalysis),
            "::",
            stringify!(forward_fft)
        )
    );
}
extern "C" {
    pub fn GetSuitableFFTSize(sample: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MyMaxInt(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MyMaxDouble(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn MyMinInt(x: ::std::os::raw::c_int, y: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn MyMinDouble(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn DCCorrection(
        input: *const f64,
        current_f0: f64,
        fs: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        output: *mut f64,
    );
}
extern "C" {
    pub fn LinearSmoothing(
        input: *const f64,
        width: f64,
        fs: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        output: *mut f64,
    );
}
extern "C" {
    pub fn NuttallWindow(y_length: ::std::os::raw::c_int, y: *mut f64);
}
extern "C" {
    pub fn GetSafeAperiodicity(x: f64) -> f64;
}
extern "C" {
    pub fn InitializeForwardRealFFT(
        fft_size: ::std::os::raw::c_int,
        forward_real_fft: *mut ForwardRealFFT,
    );
}
extern "C" {
    pub fn DestroyForwardRealFFT(forward_real_fft: *mut ForwardRealFFT);
}
extern "C" {
    pub fn InitializeInverseRealFFT(
        fft_size: ::std::os::raw::c_int,
        inverse_real_fft: *mut InverseRealFFT,
    );
}
extern "C" {
    pub fn DestroyInverseRealFFT(inverse_real_fft: *mut InverseRealFFT);
}
extern "C" {
    pub fn InitializeInverseComplexFFT(
        fft_size: ::std::os::raw::c_int,
        inverse_complex_fft: *mut InverseComplexFFT,
    );
}
extern "C" {
    pub fn DestroyInverseComplexFFT(inverse_complex_fft: *mut InverseComplexFFT);
}
extern "C" {
    pub fn InitializeMinimumPhaseAnalysis(
        fft_size: ::std::os::raw::c_int,
        minimum_phase: *mut MinimumPhaseAnalysis,
    );
}
extern "C" {
    pub fn GetMinimumPhaseSpectrum(minimum_phase: *const MinimumPhaseAnalysis);
}
extern "C" {
    pub fn DestroyMinimumPhaseAnalysis(minimum_phase: *mut MinimumPhaseAnalysis);
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL7kCutOffE"]
    pub static world_kCutOff: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL17kFloorF0StoneMaskE"]
    pub static world_kFloorF0StoneMask: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL3kPiE"]
    pub static world_kPi: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL19kMySafeGuardMinimumE"]
    pub static world_kMySafeGuardMinimum: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL4kEpsE"]
    pub static world_kEps: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL8kFloorF0E"]
    pub static world_kFloorF0: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL7kCeilF0E"]
    pub static world_kCeilF0: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL10kDefaultF0E"]
    pub static world_kDefaultF0: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL5kLog2E"]
    pub static world_kLog2: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL13kMaximumValueE"]
    pub static world_kMaximumValue: f64;
}
pub const world_kHanning: ::std::os::raw::c_int = 1;
pub const world_kBlackman: ::std::os::raw::c_int = 2;
extern "C" {
    #[link_name = "\u{1}_ZN5worldL18kFrequencyIntervalE"]
    pub static world_kFrequencyInterval: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL11kUpperLimitE"]
    pub static world_kUpperLimit: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL10kThresholdE"]
    pub static world_kThreshold: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL11kFloorF0D4CE"]
    pub static world_kFloorF0D4C: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL3kM0E"]
    pub static world_kM0: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL3kF0E"]
    pub static world_kF0: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL15kFloorFrequencyE"]
    pub static world_kFloorFrequency: f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN5worldL14kCeilFrequencyE"]
    pub static world_kCeilFrequency: f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct D4COption {
    pub threshold: f64,
}
#[test]
fn bindgen_test_layout_D4COption() {
    assert_eq!(
        ::std::mem::size_of::<D4COption>(),
        8usize,
        concat!("Size of: ", stringify!(D4COption))
    );
    assert_eq!(
        ::std::mem::align_of::<D4COption>(),
        8usize,
        concat!("Alignment of ", stringify!(D4COption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<D4COption>())).threshold as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(D4COption),
            "::",
            stringify!(threshold)
        )
    );
}
extern "C" {
    pub fn D4C(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        temporal_positions: *const f64,
        f0: *const f64,
        f0_length: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        option: *const D4COption,
        aperiodicity: *mut *mut f64,
    );
}
extern "C" {
    pub fn InitializeD4COption(option: *mut D4COption);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DioOption {
    pub f0_floor: f64,
    pub f0_ceil: f64,
    pub channels_in_octave: f64,
    pub frame_period: f64,
    pub speed: ::std::os::raw::c_int,
    pub allowed_range: f64,
}
#[test]
fn bindgen_test_layout_DioOption() {
    assert_eq!(
        ::std::mem::size_of::<DioOption>(),
        48usize,
        concat!("Size of: ", stringify!(DioOption))
    );
    assert_eq!(
        ::std::mem::align_of::<DioOption>(),
        8usize,
        concat!("Alignment of ", stringify!(DioOption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DioOption>())).f0_floor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DioOption),
            "::",
            stringify!(f0_floor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DioOption>())).f0_ceil as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DioOption),
            "::",
            stringify!(f0_ceil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DioOption>())).channels_in_octave as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DioOption),
            "::",
            stringify!(channels_in_octave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DioOption>())).frame_period as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DioOption),
            "::",
            stringify!(frame_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DioOption>())).speed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(DioOption),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DioOption>())).allowed_range as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(DioOption),
            "::",
            stringify!(allowed_range)
        )
    );
}
extern "C" {
    pub fn Dio(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        option: *const DioOption,
        temporal_positions: *mut f64,
        f0: *mut f64,
    );
}
extern "C" {
    pub fn InitializeDioOption(option: *mut DioOption);
}
extern "C" {
    pub fn GetSamplesForDIO(
        fs: ::std::os::raw::c_int,
        x_length: ::std::os::raw::c_int,
        frame_period: f64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HarvestOption {
    pub f0_floor: f64,
    pub f0_ceil: f64,
    pub frame_period: f64,
}
#[test]
fn bindgen_test_layout_HarvestOption() {
    assert_eq!(
        ::std::mem::size_of::<HarvestOption>(),
        24usize,
        concat!("Size of: ", stringify!(HarvestOption))
    );
    assert_eq!(
        ::std::mem::align_of::<HarvestOption>(),
        8usize,
        concat!("Alignment of ", stringify!(HarvestOption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HarvestOption>())).f0_floor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HarvestOption),
            "::",
            stringify!(f0_floor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HarvestOption>())).f0_ceil as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HarvestOption),
            "::",
            stringify!(f0_ceil)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HarvestOption>())).frame_period as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HarvestOption),
            "::",
            stringify!(frame_period)
        )
    );
}
extern "C" {
    pub fn Harvest(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        option: *const HarvestOption,
        temporal_positions: *mut f64,
        f0: *mut f64,
    );
}
extern "C" {
    pub fn InitializeHarvestOption(option: *mut HarvestOption);
}
extern "C" {
    pub fn GetSamplesForHarvest(
        fs: ::std::os::raw::c_int,
        x_length: ::std::os::raw::c_int,
        frame_period: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fftshift(x: *const f64, x_length: ::std::os::raw::c_int, y: *mut f64);
}
extern "C" {
    pub fn histc(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        edges: *const f64,
        edges_length: ::std::os::raw::c_int,
        index: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn interp1(
        x: *const f64,
        y: *const f64,
        x_length: ::std::os::raw::c_int,
        xi: *const f64,
        xi_length: ::std::os::raw::c_int,
        yi: *mut f64,
    );
}
extern "C" {
    pub fn decimate(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        r: ::std::os::raw::c_int,
        y: *mut f64,
    );
}
extern "C" {
    pub fn matlab_round(x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn diff(x: *const f64, x_length: ::std::os::raw::c_int, y: *mut f64);
}
extern "C" {
    pub fn interp1Q(
        x: f64,
        shift: f64,
        y: *const f64,
        x_length: ::std::os::raw::c_int,
        xi: *const f64,
        xi_length: ::std::os::raw::c_int,
        yi: *mut f64,
    );
}
extern "C" {
    pub fn randn() -> f64;
}
extern "C" {
    pub fn randn_reseed();
}
extern "C" {
    pub fn fast_fftfilt(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        h: *const f64,
        h_length: ::std::os::raw::c_int,
        fft_size: ::std::os::raw::c_int,
        forward_real_fft: *const ForwardRealFFT,
        inverse_real_fft: *const InverseRealFFT,
        y: *mut f64,
    );
}
extern "C" {
    pub fn matlab_std(x: *const f64, x_length: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn StoneMask(
        x: *const f64,
        x_length: ::std::os::raw::c_int,
        fs: ::std::os::raw::c_int,
        temporal_positions: *const f64,
        f0: *const f64,
        f0_length: ::std::os::raw::c_int,
        refined_f0: *mut f64,
    );
}
extern "C" {
    pub fn Synthesis(
        f0: *const f64,
        f0_length: ::std::os::raw::c_int,
        spectrogram: *const *const f64,
        aperiodicity: *const *const f64,
        fft_size: ::std::os::raw::c_int,
        frame_period: f64,
        fs: ::std::os::raw::c_int,
        y_length: ::std::os::raw::c_int,
        y: *mut f64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WorldSynthesizer {
    pub fs: ::std::os::raw::c_int,
    pub frame_period: f64,
    pub buffer_size: ::std::os::raw::c_int,
    pub number_of_pointers: ::std::os::raw::c_int,
    pub fft_size: ::std::os::raw::c_int,
    pub buffer: *mut f64,
    pub current_pointer: ::std::os::raw::c_int,
    pub i: ::std::os::raw::c_int,
    pub dc_remover: *mut f64,
    pub f0_length: *mut ::std::os::raw::c_int,
    pub f0_origin: *mut ::std::os::raw::c_int,
    pub spectrogram: *mut *mut *mut f64,
    pub aperiodicity: *mut *mut *mut f64,
    pub current_pointer2: ::std::os::raw::c_int,
    pub head_pointer: ::std::os::raw::c_int,
    pub synthesized_sample: ::std::os::raw::c_int,
    pub handoff: ::std::os::raw::c_int,
    pub handoff_phase: f64,
    pub handoff_f0: f64,
    pub last_location: ::std::os::raw::c_int,
    pub cumulative_frame: ::std::os::raw::c_int,
    pub current_frame: ::std::os::raw::c_int,
    pub interpolated_vuv: *mut *mut f64,
    pub pulse_locations: *mut *mut f64,
    pub pulse_locations_index: *mut *mut ::std::os::raw::c_int,
    pub number_of_pulses: *mut ::std::os::raw::c_int,
    pub impulse_response: *mut f64,
    pub minimum_phase: MinimumPhaseAnalysis,
    pub inverse_real_fft: InverseRealFFT,
    pub forward_real_fft: ForwardRealFFT,
}
#[test]
fn bindgen_test_layout_WorldSynthesizer() {
    assert_eq!(
        ::std::mem::size_of::<WorldSynthesizer>(),
        544usize,
        concat!("Size of: ", stringify!(WorldSynthesizer))
    );
    assert_eq!(
        ::std::mem::align_of::<WorldSynthesizer>(),
        8usize,
        concat!("Alignment of ", stringify!(WorldSynthesizer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).fs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).frame_period as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(frame_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).number_of_pointers as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(number_of_pointers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).fft_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(fft_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).current_pointer as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(current_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).i as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).dc_remover as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(dc_remover)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).f0_length as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(f0_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).f0_origin as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(f0_origin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).spectrogram as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(spectrogram)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).aperiodicity as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(aperiodicity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).current_pointer2 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(current_pointer2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).head_pointer as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(head_pointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).synthesized_sample as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(synthesized_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).handoff as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(handoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).handoff_phase as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(handoff_phase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).handoff_f0 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(handoff_f0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).last_location as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(last_location)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).cumulative_frame as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(cumulative_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).current_frame as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(current_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).interpolated_vuv as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(interpolated_vuv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).pulse_locations as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(pulse_locations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).pulse_locations_index as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(pulse_locations_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).number_of_pulses as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(number_of_pulses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).impulse_response as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(impulse_response)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WorldSynthesizer>())).minimum_phase as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(minimum_phase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).inverse_real_fft as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(inverse_real_fft)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WorldSynthesizer>())).forward_real_fft as *const _ as usize
        },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(WorldSynthesizer),
            "::",
            stringify!(forward_real_fft)
        )
    );
}
extern "C" {
    pub fn InitializeSynthesizer(
        fs: ::std::os::raw::c_int,
        frame_period: f64,
        fft_size: ::std::os::raw::c_int,
        buffer_size: ::std::os::raw::c_int,
        number_of_pointers: ::std::os::raw::c_int,
        synth: *mut WorldSynthesizer,
    );
}
extern "C" {
    pub fn AddParameters(
        f0: *mut f64,
        f0_length: ::std::os::raw::c_int,
        spectrogram: *mut *mut f64,
        aperiodicity: *mut *mut f64,
        synth: *mut WorldSynthesizer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn RefreshSynthesizer(synth: *mut WorldSynthesizer);
}
extern "C" {
    pub fn DestroySynthesizer(synth: *mut WorldSynthesizer);
}
extern "C" {
    pub fn IsLocked(synth: *mut WorldSynthesizer) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Synthesis2(synth: *mut WorldSynthesizer) -> ::std::os::raw::c_int;
}
